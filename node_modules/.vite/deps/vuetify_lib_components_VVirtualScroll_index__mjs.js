import {
  useDisplay
} from "./chunk-Q3X5TQ2K.js";
import {
  makeDimensionProps,
  useDimension
} from "./chunk-YNK3QM4V.js";
import {
  useResizeObserver
} from "./chunk-T66WD25A.js";
import {
  clamp,
  convertToUnit,
  createRange,
  genericComponent,
  makeComponentProps,
  propsFactory,
  useRender,
  useToggleScope
} from "./chunk-XT6SITBZ.js";
import {
  Fragment,
  computed,
  createVNode,
  onMounted,
  onUpdated,
  ref,
  shallowRef,
  toRef,
  watch,
  watchEffect
} from "./chunk-G4DFXOZZ.js";
import "./chunk-RSJERJUL.js";

// node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScroll.mjs
import "C:/Users/QAIS/Desktop/project-qais/node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScroll.css";

// node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScrollItem.mjs
var makeVVirtualScrollItemProps = propsFactory({
  dynamicHeight: Boolean,
  renderless: Boolean,
  ...makeComponentProps()
}, "VVirtualScrollItem");
var VVirtualScrollItem = genericComponent()({
  name: "VVirtualScrollItem",
  props: makeVVirtualScrollItemProps(),
  emits: {
    "update:height": (height) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    useToggleScope(() => props.dynamicHeight, () => {
      watch(() => {
        var _a;
        return (_a = contentRect.value) == null ? void 0 : _a.height;
      }, (height) => {
        if (height != null)
          emit("update:height", height);
      });
    });
    function updateHeight() {
      if (props.dynamicHeight && contentRect.value) {
        emit("update:height", contentRect.value.height);
      }
    }
    onUpdated(updateHeight);
    useRender(() => {
      var _a, _b;
      return props.renderless ? createVNode(Fragment, null, [(_a = slots.default) == null ? void 0 : _a.call(slots, {
        props: {
          ref: props.dynamicHeight ? resizeRef : void 0
        }
      })]) : createVNode("div", {
        "ref": props.dynamicHeight ? resizeRef : void 0,
        "class": ["v-virtual-scroll__item", props.class],
        "style": props.style
      }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
    });
  }
});

// node_modules/vuetify/lib/composables/virtual.mjs
var UP = -1;
var DOWN = 1;
var makeVirtualProps = propsFactory({
  itemHeight: [Number, String]
}, "virtual");
function useVirtual(props, items, offset) {
  const first = shallowRef(0);
  const baseItemHeight = shallowRef(props.itemHeight);
  const itemHeight = computed({
    get: () => parseInt(baseItemHeight.value ?? 0, 10),
    set(val) {
      baseItemHeight.value = val;
    }
  });
  const containerRef = ref();
  const {
    resizeRef,
    contentRect
  } = useResizeObserver();
  watchEffect(() => {
    resizeRef.value = containerRef.value;
  });
  const display = useDisplay();
  const sizeMap = /* @__PURE__ */ new Map();
  let sizes = createRange(items.value.length).map(() => itemHeight.value);
  const visibleItems = computed(() => {
    var _a;
    const height = (((_a = contentRect.value) == null ? void 0 : _a.height) ?? display.height.value) - ((offset == null ? void 0 : offset.value) ?? 0);
    return itemHeight.value ? Math.max(12, Math.ceil(height / itemHeight.value * 1.7 + 1)) : 12;
  });
  function handleItemResize(index, height) {
    itemHeight.value = Math.max(itemHeight.value, height);
    sizes[index] = height;
    sizeMap.set(items.value[index], height);
  }
  function calculateOffset(index) {
    return sizes.slice(0, index).reduce((curr, value) => curr + (value || itemHeight.value), 0);
  }
  function calculateMidPointIndex(scrollTop) {
    const end = items.value.length;
    let middle = 0;
    let middleOffset = 0;
    while (middleOffset < scrollTop && middle < end) {
      middleOffset += sizes[middle++] || itemHeight.value;
    }
    return middle - 1;
  }
  let lastScrollTop = 0;
  function handleScroll() {
    if (!containerRef.value || !contentRect.value)
      return;
    const height = contentRect.value.height - 56;
    const scrollTop = containerRef.value.scrollTop;
    const direction = scrollTop < lastScrollTop ? UP : DOWN;
    const midPointIndex = calculateMidPointIndex(scrollTop + height / 2);
    const buffer = Math.round(visibleItems.value / 3);
    const firstIndex = midPointIndex - buffer;
    const lastIndex = first.value + buffer * 2 - 1;
    if (direction === UP && midPointIndex <= lastIndex) {
      first.value = clamp(firstIndex, 0, items.value.length);
    } else if (direction === DOWN && midPointIndex >= lastIndex) {
      first.value = clamp(firstIndex, 0, items.value.length - visibleItems.value);
    }
    lastScrollTop = scrollTop;
  }
  function scrollToIndex(index) {
    if (!containerRef.value)
      return;
    const offset2 = calculateOffset(index);
    containerRef.value.scrollTop = offset2;
  }
  const allItems = computed(() => items.value.map((item, index) => ({
    raw: item,
    index
  })));
  const last = computed(() => Math.min(items.value.length, first.value + visibleItems.value));
  const computedItems = computed(() => allItems.value.slice(first.value, last.value));
  const paddingTop = computed(() => calculateOffset(first.value));
  const paddingBottom = computed(() => calculateOffset(items.value.length) - calculateOffset(last.value));
  onMounted(() => {
    if (!itemHeight.value) {
      itemHeight.value = sizes.slice(first.value, last.value).reduce((curr, height) => curr + height, 0) / visibleItems.value;
    }
  });
  watch(() => items.value.length, () => {
    sizes = createRange(items.value.length).map(() => itemHeight.value);
    sizeMap.forEach((height, item) => {
      const index = items.value.indexOf(item);
      if (index === -1) {
        sizeMap.delete(item);
      } else {
        sizes[index] = height;
      }
    });
  });
  return {
    containerRef,
    computedItems,
    itemHeight,
    paddingTop,
    paddingBottom,
    scrollToIndex,
    handleScroll,
    handleItemResize
  };
}

// node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScroll.mjs
var makeVVirtualScrollProps = propsFactory({
  items: {
    type: Array,
    default: () => []
  },
  ...makeVirtualProps(),
  ...makeComponentProps(),
  ...makeDimensionProps()
}, "VVirtualScroll");
var VVirtualScroll = genericComponent()({
  name: "VVirtualScroll",
  props: makeVVirtualScrollProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      containerRef,
      handleScroll,
      handleItemResize,
      scrollToIndex,
      paddingTop,
      paddingBottom,
      computedItems
    } = useVirtual(props, toRef(props, "items"));
    useRender(() => createVNode("div", {
      "ref": containerRef,
      "class": ["v-virtual-scroll", props.class],
      "onScroll": handleScroll,
      "style": [dimensionStyles.value, props.style]
    }, [createVNode("div", {
      "class": "v-virtual-scroll__container",
      "style": {
        paddingTop: convertToUnit(paddingTop.value),
        paddingBottom: convertToUnit(paddingBottom.value)
      }
    }, [computedItems.value.map((item) => createVNode(VVirtualScrollItem, {
      "key": item.index,
      "dynamicHeight": !props.itemHeight,
      "onUpdate:height": (height) => handleItemResize(item.index, height)
    }, {
      default: () => {
        var _a;
        return [(_a = slots.default) == null ? void 0 : _a.call(slots, {
          item: item.raw,
          index: item.index
        })];
      }
    }))])]));
    return {
      scrollToIndex
    };
  }
});
export {
  VVirtualScroll
};
//# sourceMappingURL=vuetify_lib_components_VVirtualScroll_index__mjs.js.map
