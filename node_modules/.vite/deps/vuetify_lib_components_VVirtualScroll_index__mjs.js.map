{
  "version": 3,
  "sources": ["../../vuetify/src/components/VVirtualScroll/VVirtualScroll.tsx", "../../vuetify/src/components/VVirtualScroll/VVirtualScrollItem.tsx", "../../vuetify/src/composables/virtual.ts"],
  "sourcesContent": ["// Styles\nimport './VVirtualScroll.sass'\n\n// Components\nimport { VVirtualScrollItem } from './VVirtualScrollItem'\n\n// Composables\nimport { makeComponentProps } from '@/composables/component'\nimport { makeDimensionProps, useDimension } from '@/composables/dimensions'\nimport { makeVirtualProps, useVirtual } from '@/composables/virtual'\n\n// Utilities\nimport { toRef } from 'vue'\nimport {\n  convertToUnit,\n  genericComponent,\n  propsFactory,\n  useRender,\n} from '@/util'\n\n// Types\nimport type { PropType } from 'vue'\nimport type { GenericProps } from '@/util'\n\nexport interface VVirtualScrollSlot<T> {\n  item: T\n  index: number\n}\n\nexport const makeVVirtualScrollProps = propsFactory({\n  items: {\n    type: Array as PropType<readonly unknown[]>,\n    default: () => ([]),\n  },\n\n  ...makeVirtualProps(),\n  ...makeComponentProps(),\n  ...makeDimensionProps(),\n}, 'VVirtualScroll')\n\nexport const VVirtualScroll = genericComponent<new <T>(\n  props: {\n    items?: readonly T[]\n  },\n  slots: {\n    default: VVirtualScrollSlot<T>\n  }\n) => GenericProps<typeof props, typeof slots>>()({\n  name: 'VVirtualScroll',\n\n  props: makeVVirtualScrollProps(),\n\n  setup (props, { slots }) {\n    const { dimensionStyles } = useDimension(props)\n    const {\n      containerRef,\n      handleScroll,\n      handleItemResize,\n      scrollToIndex,\n      paddingTop,\n      paddingBottom,\n      computedItems,\n    } = useVirtual(props, toRef(props, 'items'))\n\n    useRender(() => (\n      <div\n        ref={ containerRef }\n        class={[\n          'v-virtual-scroll',\n          props.class,\n        ]}\n        onScroll={ handleScroll }\n        style={[\n          dimensionStyles.value,\n          props.style,\n        ]}\n      >\n        <div\n          class=\"v-virtual-scroll__container\"\n          style={{\n            paddingTop: convertToUnit(paddingTop.value),\n            paddingBottom: convertToUnit(paddingBottom.value),\n          }}\n        >\n          { computedItems.value.map(item => (\n            <VVirtualScrollItem\n              key={ item.index }\n              dynamicHeight={ !props.itemHeight }\n              onUpdate:height={ height => handleItemResize(item.index, height) }\n            >\n              { slots.default?.({ item: item.raw, index: item.index }) }\n            </VVirtualScrollItem>\n          ))}\n        </div>\n      </div>\n    ))\n\n    return {\n      scrollToIndex,\n    }\n  },\n})\n\nexport type VVirtualScroll = InstanceType<typeof VVirtualScroll>\n", "// Composables\nimport { makeComponentProps } from '@/composables/component'\nimport { useResizeObserver } from '@/composables/resizeObserver'\nimport { useToggleScope } from '@/composables/toggleScope'\n\n// Utilities\nimport { onUpdated, watch } from 'vue'\nimport { genericComponent, propsFactory, useRender } from '@/util'\n\nexport const makeVVirtualScrollItemProps = propsFactory({\n  dynamicHeight: Boolean,\n  renderless: Boolean,\n\n  ...makeComponentProps(),\n}, 'VVirtualScrollItem')\n\nexport const VVirtualScrollItem = genericComponent<{ default: { props: Record<string, any> } | void }>()({\n  name: 'VVirtualScrollItem',\n\n  props: makeVVirtualScrollItemProps(),\n\n  emits: {\n    'update:height': (height: number) => true,\n  },\n\n  setup (props, { emit, slots }) {\n    const { resizeRef, contentRect } = useResizeObserver()\n\n    useToggleScope(() => props.dynamicHeight, () => {\n      watch(() => contentRect.value?.height, height => {\n        if (height != null) emit('update:height', height)\n      })\n    })\n\n    function updateHeight () {\n      if (props.dynamicHeight && contentRect.value) {\n        emit('update:height', contentRect.value.height)\n      }\n    }\n\n    onUpdated(updateHeight)\n\n    useRender(() => props.renderless ? (\n      <>\n        { slots.default?.({ props: { ref: props.dynamicHeight ? resizeRef : undefined } }) }\n      </>\n    ) : (\n      <div\n        ref={ props.dynamicHeight ? resizeRef : undefined }\n        class={[\n          'v-virtual-scroll__item',\n          props.class,\n        ]}\n        style={ props.style }\n      >\n        { slots.default?.() }\n      </div>\n    ))\n  },\n})\n", "// Composables\nimport { useDisplay } from '@/composables/display'\nimport { useResizeObserver } from '@/composables/resizeObserver'\n\n// Utilities\nimport { computed, onMounted, ref, shallowRef, watch, watchEffect } from 'vue'\nimport {\n  clamp,\n  createRange,\n  propsFactory,\n} from '@/util'\n\n// Types\nimport type { Ref } from 'vue'\n\nconst UP = -1\nconst DOWN = 1\n\ntype VirtualProps = {\n  itemHeight?: number | string\n}\n\nexport const makeVirtualProps = propsFactory({\n  itemHeight: [Number, String],\n}, 'virtual')\n\nexport function useVirtual <T> (props: VirtualProps, items: Ref<readonly T[]>, offset?: Ref<number>) {\n  const first = shallowRef(0)\n  const baseItemHeight = shallowRef(props.itemHeight)\n  const itemHeight = computed({\n    get: () => parseInt(baseItemHeight.value ?? 0, 10),\n    set (val) {\n      baseItemHeight.value = val\n    },\n  })\n  const containerRef = ref<HTMLDivElement>()\n  const { resizeRef, contentRect } = useResizeObserver()\n  watchEffect(() => {\n    resizeRef.value = containerRef.value\n  })\n  const display = useDisplay()\n\n  const sizeMap = new Map<any, number>()\n  let sizes = createRange(items.value.length).map(() => itemHeight.value)\n  const visibleItems = computed(() => {\n    const height = (contentRect.value?.height ?? display.height.value) - (offset?.value ?? 0)\n    return itemHeight.value\n      ? Math.max(12,\n        Math.ceil((height / itemHeight.value) * 1.7 + 1)\n      )\n      : 12\n  })\n\n  function handleItemResize (index: number, height: number) {\n    itemHeight.value = Math.max(itemHeight.value, height)\n    sizes[index] = height\n    sizeMap.set(items.value[index], height)\n  }\n\n  function calculateOffset (index: number) {\n    return sizes.slice(0, index).reduce((curr, value) => curr + (value || itemHeight.value), 0)\n  }\n\n  function calculateMidPointIndex (scrollTop: number) {\n    const end = items.value.length\n\n    let middle = 0\n    let middleOffset = 0\n    while (middleOffset < scrollTop && middle < end) {\n      middleOffset += sizes[middle++] || itemHeight.value\n    }\n\n    return middle - 1\n  }\n\n  let lastScrollTop = 0\n  function handleScroll () {\n    if (!containerRef.value || !contentRect.value) return\n\n    const height = contentRect.value.height - 56\n    const scrollTop = containerRef.value.scrollTop\n    const direction = scrollTop < lastScrollTop ? UP : DOWN\n\n    const midPointIndex = calculateMidPointIndex(scrollTop + height / 2)\n    const buffer = Math.round(visibleItems.value / 3)\n    const firstIndex = midPointIndex - buffer\n    const lastIndex = first.value + (buffer * 2) - 1\n    if (direction === UP && midPointIndex <= lastIndex) {\n      first.value = clamp(firstIndex, 0, items.value.length)\n    } else if (direction === DOWN && midPointIndex >= lastIndex) {\n      first.value = clamp(firstIndex, 0, items.value.length - visibleItems.value)\n    }\n\n    lastScrollTop = scrollTop\n  }\n\n  function scrollToIndex (index: number) {\n    if (!containerRef.value) return\n\n    const offset = calculateOffset(index)\n    containerRef.value.scrollTop = offset\n  }\n\n  const allItems = computed(() => items.value.map((item, index) => ({\n    raw: item,\n    index,\n  })))\n  const last = computed(() => Math.min(items.value.length, first.value + visibleItems.value))\n  const computedItems = computed(() => allItems.value.slice(first.value, last.value))\n  const paddingTop = computed(() => calculateOffset(first.value))\n  const paddingBottom = computed(() => calculateOffset(items.value.length) - calculateOffset(last.value))\n\n  onMounted(() => {\n    if (!itemHeight.value) {\n      // If itemHeight prop is not set, then calculate an estimated height from the average of inital items\n      itemHeight.value = sizes.slice(first.value, last.value).reduce((curr, height) => curr + height, 0) / (visibleItems.value)\n    }\n  })\n\n  watch(() => items.value.length, () => {\n    sizes = createRange(items.value.length).map(() => itemHeight.value)\n    sizeMap.forEach((height, item) => {\n      const index = items.value.indexOf(item)\n      if (index === -1) {\n        sizeMap.delete(item)\n      } else {\n        sizes[index] = height\n      }\n    })\n  })\n\n  return {\n    containerRef,\n    computedItems,\n    itemHeight,\n    paddingTop,\n    paddingBottom,\n    scrollToIndex,\n    handleScroll,\n    handleItemResize,\n  }\n}\n"],
  "mappings": "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",
  "names": ["makeVVirtualScrollItemProps", "propsFactory", "dynamicHeight", "Boolean", "renderless", "makeComponentProps", "VVirtualScrollItem", "genericComponent", "name", "props", "emits", "height", "setup", "_ref", "emit", "slots", "resizeRef", "contentRect", "useResizeObserver", "useToggleScope", "watch", "value", "updateHeight", "onUpdated", "useRender", "_createVNode", "_Fragment", "default", "ref", "undefined", "class", "style", "UP", "DOWN", "makeVirtualProps", "propsFactory", "itemHeight", "Number", "String", "useVirtual", "props", "items", "offset", "first", "shallowRef", "baseItemHeight", "computed", "get", "parseInt", "value", "set", "val", "containerRef", "ref", "resizeRef", "contentRect", "useResizeObserver", "watchEffect", "display", "useDisplay", "sizeMap", "Map", "sizes", "createRange", "length", "map", "visibleItems", "height", "Math", "max", "ceil", "handleItemResize", "index", "calculateOffset", "slice", "reduce", "curr", "calculateMidPointIndex", "scrollTop", "end", "middle", "middleOffset", "lastScrollTop", "handleScroll", "direction", "midPointIndex", "buffer", "round", "firstIndex", "lastIndex", "clamp", "scrollToIndex", "allItems", "item", "raw", "last", "min", "computedItems", "paddingTop", "paddingBottom", "onMounted", "watch", "forEach", "indexOf", "delete", "makeVVirtualScrollProps", "propsFactory", "items", "type", "Array", "default", "makeVirtualProps", "makeComponentProps", "makeDimensionProps", "VVirtualScroll", "genericComponent", "name", "props", "setup", "_ref", "slots", "dimensionStyles", "useDimension", "containerRef", "handleScroll", "handleItemResize", "scrollToIndex", "paddingTop", "paddingBottom", "computedItems", "useVirtual", "toRef", "useRender", "_createVNode", "class", "value", "style", "convertToUnit", "map", "item", "VVirtualScrollItem", "index", "itemHeight", "height", "raw"]
}
